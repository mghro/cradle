// #version:{{version}}#

// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT!

{% import 'enums.j2' as enums with context %}
{% import 'structures.j2' as structures with context %}
{% import 'unions.j2' as unions with context %}

// If this file is included multiple times, this code is processed each time
// to clean out preprocessor definitions.

{% for type_id in type_schemas_definition_order(api.types).keys() %}
    {% with type_info = api.types[type_id] %}

    {% if union_tag(type_info.schema) == "structure" %}
{{structures.preprocessor_cleanup_code(type_info)}}
    {% elif union_tag(type_info.schema) == "enum" %}
{{enums.preprocessor_cleanup_code(type_info)}}
    {% elif union_tag(type_info.schema) == "union" %}
{{unions.preprocessor_cleanup_code(type_info)}}
    {% endif %}

    {% endwith %}
{% endfor %}

#ifndef {{app_name | upper}}_API_HPP
#define {{app_name | upper}}_API_HPP

{% if generate_tagged_constructors %}
#include <boost/hana.hpp>
{% endif %}

#include <cradle/core/type_definitions.hpp>

namespace {{app_name}} {

{% if generate_tagged_constructors %}
template<class Arg>
struct is_hana_pair
{
    bool static const value = false;
};
template<class First, class Second>
struct is_hana_pair<boost::hana::pair<First,Second>>
{
    bool static const value = true;
};
template<class ...Args>
struct has_hana_pair
{
    bool static const value = false;
};
template<class Arg, class ...Rest>
struct has_hana_pair<Arg,Rest...>
{
    bool static const value =
        is_hana_pair<Arg>::value ||
        has_hana_pair<Rest...>::value;
};

    {% for f in unique_field_names(api.types) %}
struct {{f}}_field_tag {};
template<class T>
auto _{{f}}(T&& x)
{
    return boost::hana::make_pair(boost::hana::type_c<{{f}}_field_tag>, std::forward<T>(x));
}
    {% endfor %}
{% endif %}

{% for type_id in type_schemas_definition_order(api.types).keys() %}
    {% with type_info = api.types[type_id] %}

    {% if union_tag(type_info.schema) == "structure" %}
{{structures.forward_declaration_code(type_info)}}
    {% elif union_tag(type_info.schema) == "enum" %}
{{enums.forward_declaration_code(type_info)}}
    {% elif union_tag(type_info.schema) == "union" %}
{{unions.forward_declaration_code(type_info)}}
    {% else %}
typedef {{type_info.schema | cpp_type_for_schema()}} {{type_info.name}};
    {% endif %}

    {% endwith %}
{% endfor %}

{% for type_id in type_schemas_definition_order(api.types).keys() %}
    {% with type_info = api.types[type_id] %}

// {{type_info.name}}

    {% if type_info.doc %}
{{type_info.doc | format_comment}}
    {% endif %}

    {% if union_tag(type_info.schema) == "structure" %}
{{structures.hpp_definition_code(type_info)}}
    {% elif union_tag(type_info.schema) == "enum" %}
{{enums.hpp_definition_code(type_info)}}
    {% elif union_tag(type_info.schema) == "union" %}
{{unions.hpp_definition_code(type_info)}}
    {% endif %}

    {% endwith %}
{% endfor %}

}

#endif
