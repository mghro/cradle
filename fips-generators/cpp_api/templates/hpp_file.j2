// #version:{{version}}#

// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT!

{% import 'enums.j2' as enums with context %}
{% import 'structures.j2' as structures with context %}
{% import 'unions.j2' as unions with context %}

#include <cradle/core/type_definitions.hpp>

{% for import in api.imports %}
#include <{{import}}.hpp>
{% endfor %}

// If this file is included multiple times, this code is processed each time
// to clean out preprocessor definitions.

{% for type_id in type_schemas_definition_order(api.types).keys() %}
    {% with type_info = api.types[type_id] %}

    {% if union_tag(type_info.schema) == "structure" %}
{{structures.preprocessor_cleanup_code(type_info)}}
    {% elif union_tag(type_info.schema) == "enum" %}
{{enums.preprocessor_cleanup_code(type_info)}}
    {% elif union_tag(type_info.schema) == "union" %}
{{unions.preprocessor_cleanup_code(type_info)}}
    {% endif %}

    {% endwith %}
{% endfor %}

#ifndef {{header_file_path | upper | replace(':', '') | replace('/', '_') | replace('\\', '_') | replace('.', '_') | replace('-', '_')}}
#define {{header_file_path | upper | replace(':', '') | replace('/', '_') | replace('\\', '_') | replace('.', '_') | replace('-', '_')}}

namespace {{app_name}} {

{% if generate_tagged_constructors %}
    {% for f in unique_field_names(api.types) %}
#ifndef {{app_name | upper}}_{{f | upper}}_FIELD_TAG
#define {{app_name | upper}}_{{f | upper}}_FIELD_TAG
struct {{f}}_field_tag {};
template<class T>
auto _{{f}}(T&& x)
{
    return boost::hana::make_pair(boost::hana::type_c<{{f}}_field_tag>, std::forward<T>(x));
}
#endif
    {% endfor %}
{% endif %}

{% for type_id in type_schemas_definition_order(api.types).keys() %}
    {% with type_info = api.types[type_id] %}

    {% if union_tag(type_info.schema) == "structure" %}
{{structures.forward_declaration_code(type_info)}}
    {% elif union_tag(type_info.schema) == "enum" %}
{{enums.forward_declaration_code(type_info)}}
    {% elif union_tag(type_info.schema) == "union" %}
{{unions.forward_declaration_code(type_info)}}
    {% else %}
typedef {{type_info.schema | cpp_type_for_schema()}} {{type_info.name}};
    {% endif %}

    {% endwith %}
{% endfor %}

{% for type_id in type_schemas_definition_order(api.types).keys() %}
    {% with type_info = api.types[type_id] %}

// {{type_info.name}}

    {% if type_info.doc %}
{{type_info.doc | format_comment}}
    {% endif %}

    {% if union_tag(type_info.schema) == "structure" %}
{{structures.hpp_definition_code(type_info)}}
    {% elif union_tag(type_info.schema) == "enum" %}
{{enums.hpp_definition_code(type_info)}}
    {% elif union_tag(type_info.schema) == "union" %}
{{unions.hpp_definition_code(type_info)}}
    {% endif %}

    {% endwith %}
{% endfor %}

}

#endif
